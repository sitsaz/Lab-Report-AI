
import TurndownService from 'turndown';
import * as turndownGfmNamespace from 'turndown-plugin-gfm';
import saveAs from 'file-saver';

declare const mammoth: any;

/**
 * Converts Markdown to Word-compatible HTML with MSO headers.
 * This is a highly robust method that avoids "corrupted file" errors
 * caused by complex XML structure generation in JavaScript.
 */
const markdownToWordHtml = (markdown: string, title: string): string => {
  // Simple Markdown to HTML parser for report content
  let htmlContent = markdown
    .replace(/^# (.*$)/gim, '<h1 style="color: #2E74B5; font-size: 24pt; border-bottom: 2px solid #2E74B5;">$1</h1>')
    .replace(/^## (.*$)/gim, '<h2 style="color: #2E74B5; font-size: 18pt; margin-top: 15pt;">$1</h2>')
    .replace(/^### (.*$)/gim, '<h3 style="color: #1F4E79; font-size: 14pt;">$1</h3>')
    .replace(/\*\*(.*)\*\*/gim, '<b>$1</b>')
    .replace(/\*(.*)\*/gim, '<i>$1</i>')
    .replace(/^- (.*$)/gim, '<ul><li>$1</li></ul>')
    .replace(/<\/ul>\s*<ul>/gim, '') 
    .replace(/\n/gim, '<br />');

  // Intelligent Table conversion for Word
  if (htmlContent.includes('|')) {
    const lines = htmlContent.split('<br />');
    let inTable = false;
    let tableHtml = '<table border="1" cellspacing="0" cellpadding="5" style="border-collapse:collapse;width:100%;margin:10pt 0;font-family: Calibri, sans-serif;">';
    
    for (let i = 0; i < lines.length; i++) {
      const line = lines[i].trim();
      if (line.startsWith('|')) {
        if (!inTable) inTable = true;
        const cells = line.split('|').map(c => c.trim()).filter((c, idx, arr) => (idx !== 0 && idx !== arr.length - 1) || c !== '');
        
        if (line.includes('---')) {
          lines[i] = ''; 
          continue; 
        }
        
        const isHeader = !tableHtml.includes('<tr>');
        tableHtml += '<tr>';
        cells.forEach(cell => {
          const style = isHeader ? 'background-color:#F2F2F2;font-weight:bold;text-align:center;' : 'text-align:left;';
          tableHtml += `<td style="${style}border:1px solid #BFBFBF;">${cell}</td>`;
        });
        tableHtml += '</tr>';
        lines[i] = ''; 
      } else if (inTable) {
        tableHtml += '</table>';
        lines[i] = tableHtml + lines[i];
        inTable = false;
        tableHtml = '<table border="1" cellspacing="0" cellpadding="5" style="border-collapse:collapse;width:100%;margin:10pt 0;">';
      }
    }
    htmlContent = lines.join('<br />');
  }

  // Office XML Wrapper for native Word compatibility
  return `
    <html xmlns:o='urn:schemas-microsoft-com:office:office' xmlns:w='urn:schemas-microsoft-com:office:word' xmlns='http://www.w3.org/TR/REC-html40'>
    <head>
      <meta charset="utf-8">
      <title>${title}</title>
      <!--[if gte mso 9]>
      <xml>
        <w:WordDocument>
          <w:View>Print</w:View>
          <w:Zoom>100</w:Zoom>
          <w:DoNotOptimizeForBrowser/>
        </w:WordDocument>
      </xml>
      <![endif]-->
      <style>
        body { font-family: 'Calibri', 'Arial', sans-serif; line-height: 1.6; color: #333; padding: 40pt; }
        h1, h2, h3 { font-family: 'Segoe UI', sans-serif; }
        p { margin-bottom: 12pt; text-align: justify; }
        ul { margin-bottom: 12pt; }
        .footer { font-size: 8pt; color: #999; border-top: 1px solid #DDD; margin-top: 30pt; padding-top: 10pt; text-align: center; }
      </style>
    </head>
    <body>
      ${htmlContent}
      <div class="footer">Generated by LabReportAI Assistant. Reference ID: ${Date.now()}</div>
    </body>
    </html>
  `;
};

export const saveTextToDocx = async (markdown: string, fileName: string): Promise<void> => {
  const title = fileName.replace(/\.[^/.]+$/, "");
  const html = markdownToWordHtml(markdown, title);
  
  // Create a Blob with Word MimeType. 
  // We use .doc for this HTML-based format as it provides 100% reliability in Word without corruption errors.
  const blob = new Blob(['\ufeff', html], {
    type: 'application/msword'
  });
  
  saveAs(blob, `${title}_Assistant_Report.doc`);
};

export const copyForGoogleDocs = async (markdown: string): Promise<boolean> => {
  try {
    const html = markdownToWordHtml(markdown, "GDocs Export");
    const blobHtml = new Blob([html], { type: 'text/html' });
    const blobText = new Blob([markdown], { type: 'text/plain' });
    
    const data = [new ClipboardItem({
      'text/html': blobHtml,
      'text/plain': blobText,
    })];

    await navigator.clipboard.write(data);
    return true;
  } catch (err) {
    console.error("Clipboard export failed:", err);
    return false;
  }
};

export const extractTextFromDocx = async (file: File): Promise<string> => {
  try {
    const arrayBuffer = await file.arrayBuffer();
    const mammothInstance = (window as any).mammoth || mammoth;
    const result = await mammothInstance.convertToHtml({ arrayBuffer });
    const turndownService = new TurndownService({ headingStyle: 'atx', codeBlockStyle: 'fenced' });
    try {
      const ns = turndownGfmNamespace as any;
      const gfm = ns.gfm || ns.default?.gfm || ns.default;
      if (typeof gfm === 'function') turndownService.use(gfm);
    } catch (e) {}
    return turndownService.turndown(result.value);
  } catch (err: any) {
    throw new Error(err.message || "Extraction failed.");
  }
};
